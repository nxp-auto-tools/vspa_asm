//
// This file is generated by hand and contains the entry-points that are expected by
// BinUtils.  This file then calls the generated code created by ADL.
//

#include <string.h>
#include <stdarg.h>
#include <stdbool.h>

#include "sysdep.h"
#include "dis-asm.h"

int adl_print_insn (bfd_vma memaddr, struct disassemble_info *info,bool bigendian);

bool adl_default_is_big_endian(void);

// Print up to 4 bytes per line, trying to print out as much as possible, based upon the instruction length.
static void update_bytes_per_chunk(int len,struct disassemble_info *info)
{
  if (len % 4 == 0) {
    info->bytes_per_chunk = 4;
  } else if (len % 2 == 0) {
    info->bytes_per_chunk = 2;
  } else {
    info->bytes_per_chunk = 1;
  }
}

int print_insn_big_adl(bfd_vma memaddr, struct disassemble_info *info)
{
  int len = adl_print_insn(memaddr,info,true);
  update_bytes_per_chunk(len,info);
  return len;
}

int print_insn_little_adl(bfd_vma memaddr, struct disassemble_info *info)
{
  int len = adl_print_insn(memaddr,info,false);
  update_bytes_per_chunk(len,info);
  return len;
}


void print_adl_disassembler_options (FILE *stream ATTRIBUTE_UNUSED) { }


// This prototype duplicates the one in asm/disassembler.h, but I didn't want to include a file
// that's outside of the binutils tree.
int disassemble(char *output,unsigned memaddr,const char *input,int length,bool print_addr,const char *sep);

static void simple_print_address(bfd_vma memaddr,struct disassemble_info *info)
{
  unsigned addr = memaddr;
  (*info->fprintf_func) (info->stream, "0x%x",addr);
}

static void simple_error_func(int status, bfd_vma memaddr, struct disassemble_info *info)
{
  (*info->fprintf_func) (info->stream, "Error reading from stream %d at address 0x%x.",status,(unsigned)memaddr);
}

static int stream_read_func (bfd_vma memaddr ATTRIBUTE_UNUSED, bfd_byte *myaddr, unsigned int length,
                      struct disassemble_info *info)
{
  char *input = (char *)info->application_data;
  memcpy(myaddr,input,length);
  info->application_data = input + length;
  return 0;
}

// This tracks and updates the stream, so that we don't overwrite what we've just written.
// Note the extra level of indirection:  We're pointing to the character stream, so that we can
// update the current pointer.
static int ATTRIBUTE_PRINTF_2
tracking_sprintf (char **stream, const char *format, ...)
{
  int n;

  va_list args;
  va_start (args,format);
  n = vsprintf(*stream,format,args);
  va_end(args);
  *stream += n;
  return n;
}

//
// Interface for disassembling a stream to a buffer.
//
// output:     Output buffer (disassembled instruction text).
// memaddr:    Memory address of disassembly point.  Only relevant if the generated
//             disassembler contains instruction fields with semantic knowledge about
//             addresses or if print_addr is true.
// input:      The input buffer (binary data).
// length:     Length (in bytes) of input buffer.  The routine will keep
//             disassembling until 'length' is reached.  If length is 0, then it
//             means that we just want to disassemble a single instruction.  In
//             that case, the input is assumed to be large enough to hold enough
//             data for one instruction.  Disassembly will stop after a single
//             instruction is decoded.
// print_addr: True:  Print a leading memory address before each disassembled instruction.  This starts with
//             memaddr and advances it as necessary.
// single:     True:  Disassemble only a single instruction, even if available data remains.
// sep:        Separator string for multiple instructions.  This string is printed after each instruction
//             is disassembled.  May be 0, in which case it is ignored.
// return:     Number of bytes disassembled.
int disassemble(char *output,unsigned memaddr,const char *input,int length,bool print_addr,const char *sep)
{
  disassemble_info info;
  int width = sizeof(bfd_vma) * 2;
  const char *end = input + length;
  unsigned addr = memaddr;
  char *tmp_output = output;

  memset(&info,0,sizeof(disassemble_info));
  info.fprintf_func = (fprintf_ftype)tracking_sprintf;
  info.stream = &tmp_output;
  info.print_address_func = simple_print_address;
  info.read_memory_func = stream_read_func;
  info.memory_error_func = simple_error_func;
  info.application_data = (char*)input;
  info.buffer_length = length;

  bool big_endian = adl_default_is_big_endian();
  
  **((char**)info.stream) = '\x0';
  while ( (const char*)info.application_data < end || !length ) {
    if (print_addr) {
      (*info.fprintf_func)(info.stream,"0x%0*x:  ",width,addr);
    }
    addr += adl_print_insn(addr,&info,big_endian);
    if (!length) {
      break;
    }
    // Exit immediately if just disassembling a single instruction.
    if (!length) break;
    if (sep) {
      (*info.fprintf_func)(info.stream,"%s",sep);
    }
  }
  return (addr - memaddr);
}
